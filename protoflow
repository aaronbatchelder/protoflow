#!/bin/bash

# ProtoFlow - Prototype multiple approaches in parallel
# Usage: protoflow [options] or just protoflow for interactive mode

set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m' # No Color

# Config
PROTOFLOW_DIR="$HOME/.protoflow"
mkdir -p "$PROTOFLOW_DIR/sessions"

# Check for tmux first
if ! command -v tmux &> /dev/null; then
  echo -e "${RED}Error: tmux is required but not installed${NC}"
  echo "Install with: brew install tmux"
  exit 1
fi

# Parse arguments
PROMPT=""
REPO=""
APPROACHES=()
INTERACTIVE=false

while [[ $# -gt 0 ]]; do
  case $1 in
    --repo|-r)
      REPO="$2"
      shift 2
      ;;
    --approach|-a)
      APPROACHES+=("$2")
      shift 2
      ;;
    --help|-h)
      echo "ProtoFlow - Prototype multiple approaches in parallel"
      echo ""
      echo "Usage: protoflow                                    # Interactive mode"
      echo "       protoflow \"prompt\" --repo PATH --approach A --approach B"
      echo ""
      echo "Options:"
      echo "  --repo, -r       Path to git repository"
      echo "  --approach, -a   Constraint for an approach (can be repeated)"
      echo "  --help, -h       Show this help message"
      echo ""
      echo "Example:"
      echo "  protoflow \"Add user authentication\" \\"
      echo "    --repo ~/projects/myapp \\"
      echo "    --approach \"Use Passport.js with sessions\" \\"
      echo "    --approach \"Use JWT tokens\""
      exit 0
      ;;
    *)
      if [[ -z "$PROMPT" ]]; then
        PROMPT="$1"
      fi
      shift
      ;;
  esac
done

# If missing required args, go interactive
if [[ -z "$PROMPT" ]] || [[ -z "$REPO" ]] || [[ ${#APPROACHES[@]} -lt 2 ]]; then
  INTERACTIVE=true
fi

# Interactive mode
if [[ "$INTERACTIVE" == true ]]; then
  clear
  echo ""
  echo -e "${DIM}══════════════════════════════════════════════════════════════════════════════════${NC}"
  echo -e "${CYAN}"
  cat << 'EOF'
      ____             __       ________
     / __ \_________  / /_____  / ____/ /___ _      __
    / /_/ / ___/ __ \/ __/ __ \/ /_  / / __ \ | /| / /
   / ____/ /  / /_/ / /_/ /_/ / __/ / / /_/ / |/ |/ /
  /_/   /_/   \____/\__/\____/_/   /_/\____/|__/|__/
EOF
  echo -e "${NC}"
  echo -e "  ${DIM}Prototype multiple approaches in parallel. Merge the best one.${NC}"
  echo ""
  echo -e "${DIM}══════════════════════════════════════════════════════════════════════════════════${NC}"
  echo ""

  # Step 1: Project
  if [[ -z "$REPO" ]]; then
    echo -e "${CYAN}${BOLD}Step 1: Project${NC}"
    echo -e "${DIM}Where should we build? Enter a path or project name.${NC}"
    echo -e "${DIM}Examples: ${NC}${YELLOW}my-app${NC}${DIM}, ${NC}${YELLOW}~/projects/website${NC}${DIM}, ${NC}${YELLOW}/path/to/repo${NC}"
    echo ""

    # Default to current directory if it's a git repo
    DEFAULT_REPO=""
    if [[ -d ".git" ]]; then
      DEFAULT_REPO="$(pwd)"
      echo -e -n "${YELLOW}Project path${NC} [${DEFAULT_REPO}]: "
    else
      echo -e -n "${YELLOW}Project path${NC}: "
    fi

    read -r REPO_INPUT
    REPO="${REPO_INPUT:-$DEFAULT_REPO}"

    # Expand ~ to home directory
    REPO="${REPO/#\~/$HOME}"

    # If it's a simple name (no slashes), put it in ~/projects/
    if [[ ! "$REPO" == *"/"* ]]; then
      REPO="$HOME/projects/$REPO"
      echo -e "${DIM}Using: $REPO${NC}"
    fi
  fi

  # Validate repo - offer to create if doesn't exist
  if [[ ! -d "$REPO" ]]; then
    echo ""
    echo -e "${YELLOW}Directory doesn't exist: $REPO${NC}"
    echo -e -n "Create it as a new git repository? [Y/n]: "
    read -r CREATE_REPO
    if [[ "$CREATE_REPO" =~ ^[Nn] ]]; then
      echo -e "${RED}Cancelled${NC}"
      exit 1
    fi
    mkdir -p "$REPO"
    git -C "$REPO" init --quiet
    echo -e "${GREEN}✓${NC} Created new git repository"
  elif [[ ! -d "$REPO/.git" ]]; then
    echo ""
    echo -e "${YELLOW}Directory exists but is not a git repository${NC}"
    echo -e -n "Initialize git in $REPO? [Y/n]: "
    read -r INIT_GIT
    if [[ "$INIT_GIT" =~ ^[Nn] ]]; then
      echo -e "${RED}Cancelled${NC}"
      exit 1
    fi
    git -C "$REPO" init --quiet
    echo -e "${GREEN}✓${NC} Initialized git repository"
  fi

  echo -e "${GREEN}✓${NC} Using repository: ${REPO}"
  echo ""

  # Step 2: Task
  if [[ -z "$PROMPT" ]]; then
    echo -e "${CYAN}${BOLD}Step 2: Task${NC}"
    echo -e "${DIM}What do you want to build? Describe the feature or task.${NC}"
    echo ""
    echo -e -n "${YELLOW}Task description${NC}: "
    read -r PROMPT

    if [[ -z "$PROMPT" ]]; then
      echo -e "${RED}Error: Task description is required${NC}"
      exit 1
    fi
  fi

  echo -e "${GREEN}✓${NC} Task: ${PROMPT}"
  echo ""

  # Step 3: Approaches
  if [[ ${#APPROACHES[@]} -lt 2 ]]; then
    echo -e "${CYAN}${BOLD}Step 3: Approaches${NC}"
    echo -e "${DIM}Define 2+ different approaches to explore in parallel.${NC}"
    echo -e "${DIM}Examples: ${NC}${YELLOW}\"Use Redux\"${NC}${DIM}, ${NC}${YELLOW}\"Use Zustand\"${NC}${DIM}, ${NC}${YELLOW}\"Minimalist design\"${NC}"
    echo ""

    APPROACHES=()
    APPROACH_NUM=1

    while true; do
      LABEL="A"
      if [[ $APPROACH_NUM -eq 2 ]]; then LABEL="B"; fi
      if [[ $APPROACH_NUM -eq 3 ]]; then LABEL="C"; fi
      if [[ $APPROACH_NUM -eq 4 ]]; then LABEL="D"; fi

      if [[ $APPROACH_NUM -le 2 ]]; then
        echo -e -n "${YELLOW}Approach $LABEL${NC}: "
      else
        echo -e -n "${YELLOW}Approach $LABEL${NC} ${DIM}(or Enter to start)${NC}: "
      fi

      read -r APPROACH_INPUT

      if [[ -z "$APPROACH_INPUT" ]]; then
        if [[ $APPROACH_NUM -le 2 ]]; then
          echo -e "${RED}Need at least 2 approaches${NC}"
          continue
        else
          break
        fi
      fi

      APPROACHES+=("$APPROACH_INPUT")
      APPROACH_NUM=$((APPROACH_NUM + 1))

      if [[ $APPROACH_NUM -gt 4 ]]; then
        echo -e "${DIM}Maximum 4 approaches reached${NC}"
        break
      fi
    done
  fi

  echo ""
  echo -e "${GREEN}✓${NC} Running ${#APPROACHES[@]} approaches in parallel:"
  for i in "${!APPROACHES[@]}"; do
    LETTERS=("A" "B" "C" "D")
    echo -e "   ${CYAN}${LETTERS[$i]}${NC}: ${APPROACHES[$i]}"
  done
  echo ""

  # Confirm
  echo -e -n "${DIM}Press ${NC}${BOLD}Enter${NC}${DIM} to start or ${NC}${BOLD}Ctrl+C${NC}${DIM} to cancel...${NC} "
  read -r
  echo ""
fi

# Validate inputs (for non-interactive mode)
if [[ ! -d "$REPO" ]]; then
  echo -e "${RED}Error: Project path does not exist: $REPO${NC}"
  exit 1
fi

if [[ ! -d "$REPO/.git" ]]; then
  echo -e "${RED}Error: Not a git repository: $REPO${NC}"
  exit 1
fi

if [[ ${#APPROACHES[@]} -lt 2 ]]; then
  echo -e "${RED}Error: Need at least 2 approaches${NC}"
  exit 1
fi

# Generate session ID
SESSION_ID=$(date +%Y%m%d-%H%M%S)
SESSION_DIR="$PROTOFLOW_DIR/sessions/$SESSION_ID"
mkdir -p "$SESSION_DIR"

echo -e "${CYAN}${BOLD}Starting ProtoFlow...${NC}"
echo ""
echo -e "${DIM}Task:${NC} $PROMPT"
echo -e "${DIM}Project:${NC} $REPO"
echo -e "${DIM}Session:${NC} $SESSION_ID"
echo ""

# Create worktrees for each approach
WORKTREES=()
LETTERS=("A" "B" "C" "D")

for i in "${!APPROACHES[@]}"; do
  LETTER="${LETTERS[$i]}"
  LETTER_LOWER=$(echo "$LETTER" | tr '[:upper:]' '[:lower:]')
  CONSTRAINT="${APPROACHES[$i]}"
  BRANCH_NAME="protoflow/$SESSION_ID/approach-$LETTER_LOWER"
  WORKTREE_PATH="$SESSION_DIR/approach-$LETTER_LOWER"

  echo -e "${DIM}Creating workspace for Approach $LETTER...${NC}"

  # Create worktree
  git -C "$REPO" worktree add "$WORKTREE_PATH" -b "$BRANCH_NAME" 2>/dev/null || \
    git -C "$REPO" worktree add "$WORKTREE_PATH" "$BRANCH_NAME" 2>/dev/null

  # Assign unique port for this approach (3000 + index)
  DEV_PORT=$((3000 + i))

  # Create PROMPT.md
  cat > "$WORKTREE_PATH/PROMPT.md" << EOF
# Task

$PROMPT

## Approach

$CONSTRAINT

## Instructions

Implement the task above following the specified approach.
Work autonomously until the task is complete.

## Dev Server Port

If you need to run a dev server, use port $DEV_PORT to avoid conflicts with other approaches running in parallel.
EOF

  WORKTREES+=("$WORKTREE_PATH")
  echo -e "${GREEN}  ✓${NC} Approach $LETTER ready"
done

echo ""
echo -e "${DIM}Launching Claude agents...${NC}"
echo ""

# Create tmux session with split panes
TMUX_SESSION="protoflow-$SESSION_ID"
INITIAL_PROMPT="Read PROMPT.md and implement the task. Work autonomously until complete."

# Start tmux session with first approach
tmux new-session -d -s "$TMUX_SESSION" -c "${WORKTREES[0]}"
tmux send-keys -t "$TMUX_SESSION:0.0" "claude --dangerously-skip-permissions" Enter

# Add panes for remaining approaches
for i in "${!WORKTREES[@]}"; do
  if [[ $i -eq 0 ]]; then
    continue
  fi

  # Split horizontally for even layout
  tmux split-window -t "$TMUX_SESSION" -h -c "${WORKTREES[$i]}"
  tmux send-keys -t "$TMUX_SESSION:0.$i" "claude --dangerously-skip-permissions" Enter
done

# Even out the pane layout
tmux select-layout -t "$TMUX_SESSION" even-horizontal

# Add status bar
tmux set -t "$TMUX_SESSION" status-style "bg=#6366f1,fg=white"
tmux set -t "$TMUX_SESSION" status-left "[ProtoFlow: $SESSION_ID] "
tmux set -t "$TMUX_SESSION" status-right "Ctrl+B then D to detach"

# Wait for the bypass permissions warning to appear
sleep 2

# Accept the bypass warning in each pane (press 2 for "Yes, I accept")
for i in "${!WORKTREES[@]}"; do
  tmux send-keys -t "$TMUX_SESSION:0.$i" "2" Enter
done

echo -e "${DIM}Waiting for agents to initialize...${NC}"

# Wait for Claude to fully start after accepting (needs enough time to load)
sleep 8

# Send the prompt to each pane with enough delay between them
for i in "${!WORKTREES[@]}"; do
  LETTER="${LETTERS[$i]}"
  echo -e "${GREEN}▶${NC} Starting Approach $LETTER"
  tmux send-keys -t "$TMUX_SESSION:0.$i" "$INITIAL_PROMPT"
  sleep 0.5
  tmux send-keys -t "$TMUX_SESSION:0.$i" Enter
  sleep 3
done

echo ""
echo -e "${GREEN}${BOLD}All agents running!${NC}"
echo ""
echo -e "  ${DIM}Ctrl+B then o${NC}     Switch between panes"
echo -e "  ${DIM}Ctrl+B then D${NC}     Detach (agents keep running)"
echo -e "  ${DIM}Ctrl+B then z${NC}     Zoom current pane"
echo ""
echo -e "  ${DIM}Reattach later:${NC}   tmux attach -t $TMUX_SESSION"
echo ""

# Attach to session
tmux attach -t "$TMUX_SESSION"
